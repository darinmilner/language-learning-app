// Jenkinsfile

// Load utility functions
def terraformUtils = load "groovy/terraformUtils.groovy"
def pythonUtils = load "groovy/pythonUtils.groovy"

pipeline {
    agent {
        docker {
            image 'python:3.12'
            args '-v $HOME/.aws:/root/.aws -v /var/run/docker.sock:/var/run/docker.sock'
        }
    }
    
    parameters {
        string(name: 'DOMAIN', defaultValue: 'example.com', description: 'Domain for certificate management')
        string(name: 'AWS_REGION', defaultValue: 'us-east-1', description: 'AWS region for deployment')
        string(name: 'TF_VERSION', defaultValue: '1.1.7', description: 'Terraform version')
        string(name: 'AWS_CLI_VERSION', defaultValue: '2.4.0', description: 'AWS CLI version')
        booleanParam(name: 'DESTROY', defaultValue: false, description: 'Destroy resources after execution')
        string(name: 'TF_BACKEND_BUCKET', defaultValue: '', description: 'S3 bucket for Terraform backend')
        string(name: 'TF_BACKEND_KEY', defaultValue: 'terraform.tfstate', description: 'S3 key for Terraform backend')
        string(name: 'LOG_LEVEL', defaultValue: 'INFO', description: 'Lambda log level')
        number(name: 'MINIMUM_COVERAGE', defaultValue: 70, description: 'Minimum test coverage percentage')
    }
    
    environment {
        CERTIFICATE_BUCKET = "certificate-bucket-${params.DOMAIN}-${env.BUILD_NUMBER}"
        TF_WORKSPACE = "certificate-management-${params.DOMAIN}"
        TEST_BUCKET = "test-reports-${params.DOMAIN}"
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        
        stage('Install Tools') {
            steps {
                script {
                    terraformUtils.installTerraform(params.TF_VERSION)
                    terraformUtils.installAwsCli(params.AWS_CLI_VERSION)
                    pythonUtils.installPythonDependencies()
                }
            }
        }
        
        stage('Install Lambda Dependencies') {
            steps {
                script {
                    pythonUtils.installLambdaDependencies()
                }
            }
        }
        
        stage('Run Lambda Tests') {
            steps {
                script {
                    // Run tests for all Lambda functions
                    def testResults = pythonUtils.runLambdaTests()
                    
                    // Generate combined coverage report
                    def combinedReport = pythonUtils.generateCombinedCoverageReport(testResults, env.TEST_BUCKET)
                    
                    // Validate coverage against minimum threshold
                    pythonUtils.validateTestCoverage(testResults, params.MINIMUM_COVERAGE)
                    
                    // Store test results for later use
                    env.TEST_RESULTS = groovy.json.JsonOutput.toJson(testResults)
                }
            }
        }
        
        stage('Package Lambdas') {
            steps {
                script {
                    terraformUtils.packageLambdaFunctions()
                }
            }
        }
        
        stage('Build Lambda Layers') {
            steps {
                script {
                    terraformUtils.buildLambdaLayers()
                }
            }
        }
        
        stage('Setup Terraform Backend') {
            when {
                expression { params.TF_BACKEND_BUCKET != '' }
            }
            steps {
                script {
                    terraformUtils.setupTerraformBackend(
                        params.TF_BACKEND_BUCKET,
                        params.TF_BACKEND_KEY,
                        params.AWS_REGION
                    )
                }
            }
        }
        
        stage('Terraform Init') {
            steps {
                script {
                    terraformUtils.terraformInit('terraform')
                }
            }
        }
        
        stage('Terraform Validate') {
            steps {
                script {
                    terraformUtils.validateTerraform('terraform')
                }
            }
        }
        
        stage('Terraform Plan') {
            steps {
                script {
                    terraformUtils.terraformPlan('terraform', "-var='domain=${params.DOMAIN}' -var='certificate_bucket=${env.CERTIFICATE_BUCKET}' -var='log_level=${params.LOG_LEVEL}' -out=tfplan")
                }
            }
        }
        
        stage('Terraform Apply') {
            when {
                expression { !params.DESTROY }
            }
            steps {
                script {
                    terraformUtils.terraformApply('terraform', "tfplan")
                    
                    // Get the S3 bucket name for test reports
                    def certificateBucket = terraformUtils.terraformOutput('terraform', 's3_bucket')
                    env.DEPLOYED_BUCKET = certificateBucket
                }
            }
        }
        
        stage('Upload Test Reports') {
            when {
                expression { !params.DESTROY && env.DEPLOYED_BUCKET }
            }
            steps {
                script {
                    // Upload test reports to the deployed S3 bucket
                    def s3Path = pythonUtils.uploadTestReportsToS3(env.DEPLOYED_BUCKET, params.AWS_REGION)
                    env.TEST_REPORTS_PATH = s3Path
                    
                    echo "Test reports uploaded to: s3://${env.DEPLOYED_BUCKET}/${s3Path}/"
                }
            }
        }
        
        stage('Terraform Destroy') {
            when {
                expression { params.DESTROY }
            }
            steps {
                script {
                    terraformUtils.terraformDestroy('terraform', "-var='domain=${params.DOMAIN}' -var='certificate_bucket=${env.CERTIFICATE_BUCKET}' -var='log_level=${params.LOG_LEVEL}'")
                }
            }
        }
        
        stage('Get Outputs') {
            when {
                expression { !params.DESTROY }
            }
            steps {
                script {
                    def stepFunctionArn = terraformUtils.terraformOutput('terraform', 'step_function_arn')
                    echo "Step Function ARN: ${stepFunctionArn}"
                    
                    env.STEP_FUNCTION_ARN = stepFunctionArn
                }
            }
        }
    }
    
    post {
        always {
            script {
                // Clean up Terraform files
                terraformUtils.cleanupTerraform()
                
                // Clean up test artifacts
                sh '''
                    find . -name "*.pyc" -delete
                    find . -name "__pycache__" -type d -exec rm -rf {} + 2>/dev/null || true
                    find . -name ".pytest_cache" -type d -exec rm -rf {} + 2>/dev/null || true
                    find . -name "htmlcov" -type d -exec rm -rf {} + 2>/dev/null || true
                    find . -name ".coverage" -delete
                    find . -name "coverage.xml" -delete
                    rm -f combined-coverage-report.html
                '''
                
                cleanWs()
            }
        }
        success {
            script {
                if (!params.DESTROY && env.TEST_REPORTS_PATH) {
                    echo "‚úÖ Pipeline completed successfully"
                    echo "üìä Test reports: s3://${env.DEPLOYED_BUCKET}/${env.TEST_REPORTS_PATH}/"
                    echo "üîó Step Function: ${env.STEP_FUNCTION_ARN}"
                } else if (params.DESTROY) {
                    echo "üóëÔ∏è  Resources destroyed successfully"
                } else {
                    echo "‚úÖ Pipeline completed successfully"
                }
            }
        }
        unstable {
            echo "‚ö†Ô∏è  Pipeline completed with warnings (test coverage below threshold)"
        }
        failure {
            echo "‚ùå Pipeline failed"
        }
    }
}